<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
		Remove this if you use the .htaccess -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

		<title>Watson</title>

		<!-- Google fonts -->
	    <link href='http://fonts.googleapis.com/css?family=Exo+2' rel='stylesheet' type='text/css'>
		<link href = "../lib/images/favicon.ico" rel="icon" type="image/png">

	    <!-- CSS files -->
		<link href="../lib/css/bootstrap.css" rel = "stylesheet">
	    <link rel="stylesheet" type="text/css" href="../lib/css/jquery-ui-1.10.4.custom.css">
	    <link href = "../lib/css/styles.css" rel = "stylesheet">
	    <link href = "../lib/css/generalmedia.css" rel = "stylesheet">
		
	    <!-- Java Script files -->
		<script type="text/javascript" src="../lib/js/master.js"></script>
	    <script type="text/javascript" src="../lib/js/jquery-1.10.2.js"></script>
		<script type="text/javascript" src="../lib/js/bootstrap.min.js"></script>
	    <script type="text/javascript" src="../lib/js/jquery-ui-1.10.4.custom.js"></script>
		<script type="text/javascript" src="js/kinetic.js"></script>
		<script type="text/javascript" src="../lib/js/Numbering.js"></script>
		<script type="text/javascript" src="../lib/js/Miscellaneous.js"></script>
		<script type="text/javascript" src="../lib/js/nav.js"></script>
		<link href = "../lib/css/Dialogs.css" rel = "stylesheet">
		<meta name="viewport" content="width=device-width; initial-scale=1.0">
	</head>
	
	<body>
		<div id="includedContentForPage"></div>
		<div id="wrapper" class="page-wrapper">
			<a id="tippytop"></a>
			<!-- Header division -->
			<!-- End nav -->

			<!-- Main content -->
			
			<p class="Section">
				<span class="contentNum circuitsCombinatorial3"></span>
			</p>


			<p>
				An “adder”, as its name implies, is a circuit for adding binary numbers. In <span class="contentNum assembly"></span> (<span class="contentNum assemblyData1b3"></span>) we studied binary arithmetic, including binary addition. As you may recall from that discussion, the addition of two single-bit binary numbers can be defined by a table such as:
			</p>

			<img src="images/fig12-addertable.png" alt="Adder Table" class="ImageTall">
			
			<p>
				<span>where “A” and “B” represent the two single-bit inputs, “S” represents the sum of those inputs, and “C” represents a possible carry. The first line of the table illustrates “0 + 0” equals “0”. Lines two and three correspond to “0 + 1” and “1 + 0” both of which equal “1”. The last line of the table represents “1 + 1” which equals two (10</span><span class="Subscript">two</span> <span>). This value is represented by placing a “0” in S, the sum, and a “1” in C, the carry.</span>
			</p>

			<p>
				<span>A circuit to implement the behavior of this table will need two inputs (one for each of the single-bit numbers) and two outputs (one for the sum and one for the carry). Constructing such a circuit is fairly straightforward. Notice that the values in the S column correspond to an exclusive or,</span> <span class="Ital">xor</span> <span>, of the two inputs, while the values in the C column correspond to an</span> <span class="Ital">and</span> <span>of both inputs. The circuit can thus be constructed from these two sub-circuits as illustrated in <span class="figNum halfadder"></span>.</span>
			</p>

			<div id="topDiv-13" class="Centered"></div>
			<div id="container-13" class="Centered"></div>

			<p class="Figure">
				<span class="figNum halfadder"></span> An implementation of a “half adder”
			</p>

			<p>
				<span>This circuit is called a “half adder”. While a half</span> <span>adder does add two single-bit numbers and can generate a carry, it has no provision for a carry</span> <span class="Ital">input</span> <span>into the circuit. Recall from our discussion of binary addition that when adding two multi-bit binary numbers one works column by column from right to left making sure that the carry bit from the previous column is added into the current column. Here is an illustration of this process on six and seven, represented as four-bit unsigned binary numbers.</span>
			</p>

			<img src="images/fig12-carryillus.png" alt="" class="Image">

			<p>
				A half adder could be used to add the right-most (low-order) bits of the two numbers, but it is not general enough to add the digits of an arbitrary column, since it does not support a carry as input.
			</p>

			<p>
				<span>A “full adder” overcomes this limitation of the half adder by allowing a carry to be fed into the circuit along with a bit from each of the numbers to be added. Thus, a full adder will have three inputs: the two bits being added plus the carry in. Only two output bits, the “sum” and “carry out”, are needed because the largest result that can be produced by the circuit will be three (11</span><span class="Subscript">two</span> <span>). This occurs when all three inputs are set to “1”. Here is a complete truth table for a full adder. The inputs have been labeled “C</span><span class="Subscript">in</span> <span>”, “A”, and “B”; the outputs “C</span><span class="Subscript">out</span> <span>” and “S”.</span>
			</p>

			<img src="images/fig12-carrytable.png" alt="" class="Image">
			
			<p>
				Designing a circuit to implement this behavior “from scratch” would be challenging. However, through careful observation and the use of two half adders, the job is manageable. Since we’ll be using half adders to build the full adder, our circuit diagram will be simpler if we imagine the half adder encapsulated into a “black box”, as shown below:
			</p>

			<img src="images/halfadderillus.png" alt="" class="ImageTall">
			<img src="images/fulladderillus.png" alt="" class="Image">
			
			<p class="Figure">
				<span class="figNum fulladder"></span> A full adder implemented using two half adders
			</p>

			<p>
				<span>The trick to building a full adder is to think of the sum of the three terms, A + B +C</span><span class="Subscript">in</span> <span>, as a sequence of two sums associated left to right: ( A + B ) + C</span><span class="Subscript">in</span> <span>. One half adder will be used to compute the sum A&nbsp;+&nbsp;B. The “sum” bit output by this half adder, along with C</span><span class="Subscript">in</span> <span>, will be fed as input into a second half adder. The “sum” bit produced by the second half adder will serve as the “sum” bit of the full adder. The “carry out” bit of the full adder is produced by routing the “carry out” bits of both half adders into an</span> <span class="Ital">or</span> <span>gate.</span>
			</p>

			<p>
				<span><span class="figNum fulladder"></span> illustrates the full adder in outline form. Development of a complete implementation of the full adder using only</span> <span class="Ital">and</span> <span>,</span> <span class="Ital">or</span> <span>, and</span> <span class="Ital">not</span> <span>gates is left as an exercise. You should also be sure to verify that this circuit does, in fact, generate the truth table for binary addition.</span>
			</p>

			<p>
				Just as we encapsulated the half adder, we can encapsulate the single-bit full adder into a black box.
			</p>
			
			<img src="images/fig12-fulladderencap.png" alt="" class="ImageTall">

			<p>
				This representation looks a little different than the circuit of <span class="figNum fulladder"></span> because it has been rotated clockwise 90&deg; to make the following diagram easier to read. Be assured, however, that the inputs, outputs, behavior, and internal details of the circuit remain unchanged.
			</p>

			<img src="images/fourbitadder.png" alt="" class="Image">

			<p class="Figure">
				<span class="figNum fourbitadder"></span> An implementation for a four-bit adder using four one-bit adders
			</p>

			<p>
				Multi-bit adders can be implemented as a chain of single-bit full adders where the “carry out” of each adder is routed to the “carry in” of the adder immediately to its left. Under this scheme each full adder is essentially responsible for adding a single bit of each of the two input numbers, plus the carry bit generated by the adder immediately to its right. The “carry in” for the rightmost adder is permanently set to 0. The “carry out” of the leftmost adder indicates whether or not addition of the inputs produces an overflow.
			</p>

			<p>
				<span><span class="figNum fourbitadder"></span> illustrates a four-bit adder constructed from four single-bit adders. In this example, input A holds the number six (0110</span><span class="Subscript">two</span> <span>) while input B holds seven (0111</span><span class="Subscript">two</span> <span>). </span> <span>The result of this addition operation is the four-bit unsigned number 1101</span><span class="Subscript">two</span> <span>, or thirteen, with a carry (overflow) of zero.</span>
			</p>

			<p class="Exercise">
				Exercises for <span class="contentNum circuitsCombinatorial3"></span>
			</p>

			<ol id="exerciseList">
				<li>
					<p class="exercise solvable 14">
						Draw the complete circuit for a single-bit full adder using only gates, wires, and connectors.&nbsp;
					</p>
					
					<div class="exerciseDiv 14"></div>
				</li>

				<li>
					<p class="exercise solvable 15">
						Draw the complete circuit for a two-bit full adder using only gates, wires, and connectors.&nbsp;
					</p>
					
					<div class="exerciseDiv 15"></div>
				</li>
			</ol>
			<!-- Sandbox -->
			<p class="Section" id="Scratch"></p>
			<div id="sandbox1"></div>
			<div id="truthTableDiv1" class="ui-widget-content" style="position: relative; visibility: hidden"></div>


			<!-- End main content -->
			<div class="push"></div>
			</div>
			
			<div class="blueFooterBar"></div>
		
		<!-- Figure js -->
		<script src="js/visibility.js"></script>
		<script type="text/javascript" src="js/global.js"></script>
		<script src="../lib/js/WatsonDataStore.js"></script>
		<script src="../lib/js/WatsonDialogs.js"></script>
		<script src="js/Serializer.js"></script>
		<script src="js/Controller.js"></script>
		<script src="js/AndGate.js"></script>
		<script src="js/AndGate3.js"></script>
		<script src="js/AndGate4.js"></script>
		<script src="js/NandGate.js"></script>
		
		<script src="js/OrGate.js"></script>
		<script src="js/OrGate3.js"></script>
		<script src="js/OrGate4.js"></script>
		<script src="js/NorGate.js"></script>
		
		<script src="js/NotGate.js"></script>
		<script src="js/Connector.js"></script>
		<script src="js/InputNode.js"></script>
		<script src="js/OutputNode.js"></script>
		<script src="js/PopupMenu.js"></script>
		<script src="js/Figures.js"></script>
		<script src="js/TruthTable.js"></script>
		<script src="js/Setup.js"></script>
		<script src="js/DigitalLogicFigure.js"></script>
		
		<script>
			var pageObj;											// do NOT change name of variable
			var chapID = "circuits";
			var sectID = "circuitsCombinatorial3";
			
			$(document).ready(function() {
				populateNav();										// populate nav content
				populateSpans();									// populate figure/content spans
				pageObj = getArrowPathsByPage(sectID);				// get arrow paths
				
				var figure13 = new DigitalLogicFigure("container-13", "13", false, false, "halfadder"); 
				
				setupExerciseButtons(sectID);
				
				if (!localFlag) runGA();
			});	
			
		</script>
	</body>
</html>
